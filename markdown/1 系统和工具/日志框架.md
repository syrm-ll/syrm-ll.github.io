# 日志接口: SLF4J

## 介绍

`SLF4J` 全名: `Simple Logging Facade for Java`

> SimpleLoggingFacadeforJava（SLF4J）作为各种日志框架（例如。java.util.logging文件，logback，log4j），允许最终用户在部署时插入所需的日志框架。
>
> 请注意，启用库的SLF4J意味着只添加一个强制依赖项，即SLF4J-api.jar文件. 如果在类路径上找不到绑定，那么SLF4J将默认为无操作实现。



主要版本变化:

> `SINCE 1.6.0` If no binding is found on the class path, then SLF4J will default to a no-operation implementation.
>
> `SINCE 1.7.0` Printing methods in the Logger interface now offer variants accepting varargs instead of Object[]. This change implies that SLF4J requires JDK 1.5 or later. Under the hood the Java compiler transforms the varargs part in methods into Object[]. Thus, the Logger interface generated by the compiler is indistinguishable in 1.7.x from its 1.6.x counterpart. It follows that SLF4J version 1.7.x is totally 100% no-ifs-or-buts compatible with SLF4J version 1.6.x.
>
> `SINCE 1.7.5` Significant improvement in logger retrieval times. Given the extent of the improvement, users are highly encouraged to migrate to SLF4J 1.7.5 or later.
>
> `SINCE 1.7.9` By setting the slf4j.detectLoggerNameMismatch system property to true, SLF4J can automatically spot incorrectly named loggers.
>
> `SINCE 2.0.0` SLF4J API version 2.0.0 requires Java 8 and introduces a backward-compatible fluent logging API. By backward-compatible, we mean that existing logging frameworks do not have to be changed in order for the user to benefit from the fluent logging API.

机器翻译:

> `从1.6.0开始`，如果在类路径上找不到绑定，那么SLF4J将默认为无操作实现。
>
> `从1.7.0开始` Logger接口中的打印方法现在提供接受varargs而不是Object[]的变体。此更改意味着SLF4J需要JDK1.5或更高版本。在这种情况下，Java编译器将方法中的varargs部分转换为Object[]。因此，编译器生成的Logger接口在1.7.x版本中与1.6.x版本中是无法区分的。因此，SLF4J版本1.7.x与SLF4J版本1.6.x完全没有ifs或BUT兼容。
>
> `自1.7.5以来`，记录器检索时间显著提高。鉴于改进的程度，强烈鼓励用户迁移到SLF4J 1.7.5或更高版本。
>
> `由于1.7.9`通过将slf4j.detectLoggerNameMismatch系统属性设置为true，slf4j可以自动发现名称不正确的记录器。
>
> `由于2.0.0`，slf4japi版本2.0.0需要java8，并引入了向后兼容的fluent日志API。通过向后兼容，我们的意思是现有的日志框架不必为了用户从fluent日志API中获益而改变。

**总结**

2.0 版本之后支持Steam API 并且向下兼容

2.0 之前使用方式不变



目前(2021年2月26日) 最新稳定版本为 : `1.7.30`

---

推荐日志实现:

SLF4J的简单实现: slf4j-silple

> testImplementation group: 'org.slf4j', name: 'slf4j-simple', version: '1.7.30'

SLF4J 的原生实现: logback

> testImplementation group: 'ch.qos.logback', name: 'logback-classic', version: '1.2.3'



## 依赖 和 选择日志实现

如果不需要日志实现(不会打印日志), 只需要依赖 `slf4j-api`

如果使用原生实现 `slf4j-sliple` 或 `logbak`  需要依赖:  `slf4j-api`  和对应的实现

如果使用其他日志框架, 还需要一个 `slf4j-XXX` 的兼容包



如果其他框架已经使用了其他日志(非SLF4J), 可以排除原有依赖后,添加  `XXX-slf4j` 的伪装包, 然后使用 `slf4j-api 和日志实现`



## 使用: 传统API

### 创建日志记录器对象

```java
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


Logger log = LoggerFactory.getLogger(HelloWorld.class);
```



### 日志打印

```java
		log.error("错误");
        log.warn("警告");
        log.info("信息");
        log.debug("调试");
        log.trace("追踪");
```



### 占位符 {}

```java
log.debug("姓名: {} \t 性别: {}", "testname", "女");
```



**没了!  就这些 (╯‵□′)╯︵┻━┻**





## 使用: Stream API

**略!**



---



# LogBack实现

## 介绍

> Logback是流行的log4j项目的继承者，从log4j离开的地方开始。
>
> Logback的体系结构具有足够的通用性，可以在不同的情况下应用。目前，logback分为logback核心、logback经典和logback访问三个模块。
>
> logback核心模块为其他两个模块奠定了基础。logback classic模块可以被同化为log4j的一个显著改进的版本。此外，logback classic本机实现了SLF4J API，因此您可以在logback和其他日志框架（如log4j或log4j）之间轻松切换java.util.logging文件（七月）。
>
> logback访问模块与Servlet容器（如Tomcat和Jetty）集成，以提供HTTP访问日志功能。请注意，您可以轻松地在logback核心之上构建自己的模块。



**logback-core: 为下面两位提供支持**

**logback-classic: 真正的日志框架**

**logback-access: 和Servlet 集成, 提供HTTP访问日志**



## 依赖





## 配置

logback 寻找配置文件规则:

> 1. logback-test.xml
> 2. logback.groovy
> 3. logback.xml
> 4. 使用[服务提供商加载设施](http://docs.oracle.com/javase/6/docs/api/java/util/ServiceLoader.html)（在 JDK 1.6 中引入）通过查找类路径中的文件*META-INF 服务\ch.qos.logback.classic.spi.配置器*来解决[`com.qos.logback.classic.`](http://logback.qos.ch/xref/ch/qos/logback/classic/spi/Configurator.html)配置器的实现问题。其内容应指定所需实施的完全合格的类名称。`Configurator`
> 5. 上述任何一项都未成功，则使用[`"基础配置器`](http://logback.qos.ch/xref/ch/qos/logback/classic/BasicConfigurator.html)"自动重新配置自己，这将导致将记录输出定向到控制台。
>
> > **快速启动**Joran 解析给定的日志备份配置文件大约需要 100 毫秒。要在申请启动时剃掉这些密秒，您可以使用服务提供商加载设施（上图 4 项）加载您自己的自定义类，[基础集成器](http://logback.qos.ch/xref/ch/qos/logback/classic/BasicConfigurator.html)作为良好的起点。`Configurator`
>
> ```java
> // 打印日志记录器状态
> // print internal state
> LoggerContext lc = (LoggerContext) LoggerFactory.getILoggerFactory();
> StatusPrinter.print(lc);
> ```
>
> 打印日志记录器状态(基本就是启动日志), 可以方便检查日志配置文件问题



### 基本的xml配置

相当于寻找配置文件步骤5中的默认配置:

```xml
<configuration>

  <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
    <!-- encoders are assigned the type
         ch.qos.logback.classic.encoder.PatternLayoutEncoder by default -->
    <encoder>
      <pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
    </encoder>
  </appender>

  <root level="debug">
    <appender-ref ref="STDOUT" />
  </root>
</configuration>
```

---

### 配置文件语法

#### 标签名大小写规范

无法确定不同版本对标签大小写规则的要求, 需要注意有时标签大小写不同会导致配置无效.

> 官网: 如果你不确定用于给定标签名称的是那个案例, 只需遵循驼峰命名规则, (几乎始终是正确的约定)



#### 配置 Logger

此时，您至少应该对级别继承和基本选择规则有一些了解。(在官网文档中介绍)

**简单介绍: 和 CSS 类似, 范围越小优先级越高, 如果没有设置,取最近的父级**

也就是 ROOT 可以设置为 OFF, 其他的子项单独设置, 不影响日志打印.

> 元素只接受一个必需的name属性、一个可选的level属性和一个可选的additivity属性，
>
> **level属性的值可以是不区分大小写的字符串TRACE、DEBUG、INFO、WARN、ERROR、ALL或OFF之一。请注意，根记录器的级别不能设置为INHERITED或NULL**
>
> 和其他元素类似, 这个元素可以包含零个或多个元素；这样引用的每个**appender**都被添加到根记录器中。请注意，与log4j不同，logback classic在配置根记录器时不会关闭或删除任何先前引用的附加器

**示例:**

```xml
语法: level 可选 -> TRACE, DEBUG, INFO, WARN, ERROR, ALL or OFF
<logger name="" [level = ""] [additivity=""]>

例:
	<logger name="chapters.configuration" level="INFO" />

  <!-- turn OFF all logging (children can override) -->
  <root level="OFF">
    <appender-ref ref="STDOUT" />
  </root>
```







### Configuration 配置

#### 自动加载配置文件变化

手动指定配置文件位置, 并且更改配置文件如下: (具体的变化可以打印日志记录器状态观察)

```java
// 指定配置文件位置, 必须在任何日志记录器创建之前执行.
System.setProperty(ClassicConstants.CONFIG_FILE_PROPERTY, "logback.xml");
```

```xml
<configuration scan="true">
	...
</configuration>
```

可以在配置文件发生变化时自动加载更新

默认情况下，配置文件将每分钟扫描一次更改。您可以通过设置元素的*扫描周期*属性来指定不同的扫描周期。值可以以毫秒、秒、分钟或小时为单位指定。下面是一个例子：

```xml
<configuration scan="true" scanPeriod="30 seconds" >
  ...
</configuration>
```

**注意事项**如果没有指定时间单位，则假定时间单位为毫秒，这通常不合适。如果您更改了默认扫描周期，请不要忘记指定时间单位。

在幕后，当您将扫描属性设置为[`"重新配置"时，将安装"改变任务`](http://logback.qos.ch/xref/ch/qos/logback/classic/joran/ReconfigureOnChangeTask.html)"。此任务以单独的线程运行，并将检查您的配置文件是否已更改。 将自动观看任何[包含](http://logback.qos.ch/manual/configuration.html#fileInclusion)的文件，以及。`true``ReconfigureOnChangeTask`

由于编辑配置文件时很容易出错，因此，如果配置文件的最新版本有 XML 语法错误，它将返回到以前的配置文件，没有 XML 语法错误。

#### 启用堆栈痕迹包装数据

**注意事项**截至第 1.1.4 版，默认情况下禁用包装数据。

如果指示这样做，日志返还可以包括其输出的堆栈跟踪线中每行的包装数据。当堆栈跟踪线的类别开始时，包装数据由罐文件的名称和版本组成。包装数据在识别软件版本问题方面非常有用。但是，计算成本相当高，尤其是在经常抛出异常的应用程序中。

默认情况下，包装数据已禁用，但可以通过配置启用：

```xml
<configuration packagingData="true">
  ...
</configuration>
```

或者，包装数据可以通过调用[设置的包装数据（布尔）](http://logback.qos.ch/apidocs/ch/qos/logback/classic/LoggerContext.html#setPackagingDataEnabled(boolean))方法（如下所示）来实现/禁用：`LoggerContext`

```java
  LoggerContext lc = (LoggerContext) LoggerFactory.getILoggerFactory();
  lc.setPackagingDataEnabled(true);
```



### 查看状态信息

> 日志备份在对象中收集其内部状态数据，可通过。`StatusManager``LoggerContext`
>
> 给定一个，您可以访问与日志返还上下文关联的所有状态数据。为了将内存使用保持在合理的水平，默认实施将状态消息存储在两个单独的部分：标题部分和尾部。标题部分存储第一个*H*状态消息，而尾部分存储最后*一*个 T 消息。目前H=T=150，尽管这些值可能会在未来版本中发生变化。 `StatusManager``StatusManager`
>
> 具有名为"查看状态信息服务"的伺服器的回溯经典船舶。此伺服器将与电流关联的内容打印为 HTML 表。下面是样本输出。`StatusManager``LoggerContext`



要将此伺服器添加到您的 Web 应用程序中，请在其*WEB-INF/Web .xml文件中*添加以下行。

**WEB-INF/Web.xml**

```xml
  <servlet>
    <servlet-name>ViewStatusMessages</servlet-name>
    <servlet-class>ch.qos.logback.classic.ViewStatusMessagesServlet</servlet-class>
  </servlet>

  <servlet-mapping>
    <servlet-name>ViewStatusMessages</servlet-name>
    <url-pattern>/lbClassicStatus</url-pattern>
  </servlet-mapping>
```



### 收听状态信息

XML配置, 注册状态监听器

```xml
<configuration debug="true" scan="true">
    <!-- 注册状态监听器 -->
    <ststusListener class="ch.qos.logback.core.status.OnConsoleStatusListener"/>
</configuration>
```

java 配置, 注册状态监听器

```java
   LoggerContext lc = (LoggerContext) LoggerFactory.getILoggerFactory();
   StatusManager statusManager = lc.getStatusManager();
   OnConsoleStatusListener onConsoleListener = new OnConsoleStatusListener();
   statusManager.add(onConsoleListener);
```



**注意:**

注册状态侦听器仅在注册后接收状态事件。它不会收到之前的消息。因此，通常最好在其他指令之前将状态侦听器注册指令放在配置文件的顶部。也可以在配置文件中注册一个或多个状态侦听器。





## 关闭

当不需要日志记录器时,可以手动关闭日志上下文, 释放所有已定义的日志记录器,停止任何活动线程.

```java
import org.sflf4j.LoggerFactory;
import ch.qos.logback.classic.LoggerContext;
...

// assume SLF4J is bound to logback-classic in the current environment
LoggerContext loggerContext = (LoggerContext) LoggerFactory.getILoggerFactory();
loggerContext.stop();
```



### 通过关机挂钩停止logback

```xml
<configuration debug="true">
   <!-- in the absence of the class attribute, assume
   ch.qos.logback.core.hook.DefaultShutdownHook -->
   <shutdownHook/>
  ....
</configuration>
```

**注意:**  您可以通过设置*类*属性来对应关机钩的类名称来安装自己制作的关机钩。

> 默认关机钩（即[默认ShutdownHook）](http://logback.qos.ch/apidocs/ch/qos/logback/core/hook/DefaultShutdownHook.html)将在指定延迟（默认情况下为 0）后**停止**回退上下文。停止上下文将允许在后台运行的任何日志文件压缩任务最多 30 秒完成。在独立的 Java 应用程序中，向配置文件添加指令是确保允许在 JVM 退出之前完成任何正在进行的压缩任务的简单方法。



在JavaWeb应用程序中, `WebShutdownHook`  关机钩子会自动安装, 不需要显式配置, 如果不想自动安装可以在Web.xml 文件中设置:

**Web.xml**

```xml
<web-app>
    <context-param>
        <param-name>logbackDisableServletContainerInitializer</param-name>
        <param-value>true</param-value>
    </context-param>
    ....
</web-app>
```

请注意，变量也可以设置为 Java 系统属性操作系统环境变量。大多数本地设置具有优先级，即 Web 应用优先、系统属性第二和操作系统环境最后。`logbackDisableServletContainerInitializer`
